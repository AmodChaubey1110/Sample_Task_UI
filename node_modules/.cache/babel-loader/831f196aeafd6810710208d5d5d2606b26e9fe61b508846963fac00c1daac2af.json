{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nconst newLine = '\\r\\n';\nconst raf = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : process.nextTick;\nconst makeWrapper = wrapChar => str => `${wrapChar}${str}${wrapChar}`;\nconst makeResolver = (resolve, newLineAtEnd) => content => {\n  if (newLineAtEnd) {\n    content.push('');\n  }\n  resolve(content.join(newLine));\n};\nconst identityMapping = (arr, initialMapping) => arr.reduce((acc, k) => {\n  acc[k] = k;\n  return acc;\n}, initialMapping);\nconst extractHeaderFromData = datas => datas.reduce((acc, v) => Array.isArray(v) ? acc : identityMapping(Object.keys(v), acc), {});\nconst extractHeaderFromColumns = columns => columns.reduce((acc, v) => {\n  var _a;\n  if (typeof v === 'string') {\n    acc[v] = v;\n  } else {\n    acc[v.id] = (_a = v.displayName) !== null && _a !== void 0 ? _a : v.id;\n  }\n  return acc;\n}, {});\nfunction toChunks(arr, chunkSize) {\n  return [...Array(Math.ceil(arr.length / chunkSize))].reduce((acc, _, i) => {\n    const begin = i * chunkSize;\n    return acc.concat([arr.slice(begin, begin + chunkSize)]);\n  }, []);\n}\nconst createChunkProcessor = (resolve, wrap, content, datas, columnOrder, separator, chunkSize) => {\n  const chunks = toChunks(datas, chunkSize);\n  let i = 0;\n  return function processChunk() {\n    if (i >= chunks.length) {\n      resolve(content);\n      return;\n    }\n    const chunk = chunks[i];\n    i += 1;\n    chunk.map(v => Array.isArray(v) ? v : columnOrder.map(k => {\n      var _a;\n      return (_a = v[k]) !== null && _a !== void 0 ? _a : '';\n    })).forEach(v => {\n      content.push(v.map(wrap).join(separator));\n    });\n    raf(processChunk);\n  };\n};\nexport default function csv(_ref) {\n  let {\n    columns,\n    datas,\n    separator = ',',\n    noHeader = false,\n    wrapColumnChar = '',\n    newLineAtEnd = false,\n    chunkSize = 1000\n  } = _ref;\n  return __awaiter(this, void 0, void 0, function* () {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise((_resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      const resolve = makeResolver(_resolve, newLineAtEnd);\n      const wrap = makeWrapper(wrapColumnChar);\n      try {\n        datas = typeof datas === 'function' ? yield datas() : yield datas;\n        if (!Array.isArray(datas)) {\n          return _resolve();\n        }\n        const header = columns ? extractHeaderFromColumns(columns) : extractHeaderFromData(datas);\n        const content = [];\n        if (!noHeader) {\n          const headerNames = Object.values(header);\n          if (headerNames.length > 0) {\n            content.push(headerNames.map(wrap).join(separator));\n          }\n        }\n        const columnOrder = Object.keys(header);\n        const processChunk = createChunkProcessor(resolve, wrap, content, datas, columnOrder, separator, chunkSize);\n        raf(processChunk);\n      } catch (err) {\n        return reject(err);\n      }\n    }));\n  });\n}","map":{"version":3,"names":["newLine","raf","requestAnimationFrame","process","nextTick","makeWrapper","wrapChar","str","makeResolver","resolve","newLineAtEnd","content","push","join","identityMapping","arr","initialMapping","reduce","acc","k","extractHeaderFromData","datas","v","Array","isArray","Object","keys","extractHeaderFromColumns","columns","id","_a","displayName","toChunks","chunkSize","Math","ceil","length","_","i","begin","concat","slice","createChunkProcessor","wrap","columnOrder","separator","chunks","processChunk","chunk","map","forEach","csv","_ref","noHeader","wrapColumnChar","Promise","_resolve","reject","__awaiter","header","headerNames","values","err"],"sources":["/home/acc/Desktop/Task/task/node_modules/react-csv-downloader/src/lib/csv.ts"],"sourcesContent":["export interface IColumn {\n  displayName?: string\n  id: string\n}\n\nexport type ColumnsDefinition = (string | IColumn)[]\nexport type Columns = ColumnsDefinition | undefined | false\nexport type Datas = (string[] | { [key: string]: string | null | undefined })[]\n\nconst newLine = '\\r\\n'\nconst raf = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : process.nextTick\n\nconst makeWrapper = (wrapChar: string) => (str: string) => `${wrapChar}${str}${wrapChar}`\nconst makeResolver = (resolve: (result: string) => unknown, newLineAtEnd: boolean) => (content: string[]) => {\n  if (newLineAtEnd) {\n    content.push('')\n  }\n\n  resolve(content.join(newLine))\n}\n\nconst identityMapping = (arr: string[], initialMapping: Record<string, string>): Record<string, string> =>\n  arr.reduce((acc, k) => {\n    acc[k] = k\n    return acc\n  }, initialMapping)\n\nconst extractHeaderFromData = (datas: Datas): Record<string, string> =>\n  datas.reduce((acc: Record<string, string>, v) => (Array.isArray(v) ? acc : identityMapping(Object.keys(v), acc)), {})\n\nconst extractHeaderFromColumns = (columns: ColumnsDefinition): Record<string, string> =>\n  columns.reduce((acc: Record<string, string>, v) => {\n    if (typeof v === 'string') {\n      acc[v] = v\n    } else {\n      acc[v.id] = v.displayName ?? v.id\n    }\n    return acc\n  }, {})\n\nfunction toChunks<T>(arr: T[], chunkSize: number): T[][] {\n  return [...Array(Math.ceil(arr.length / chunkSize))].reduce((acc, _, i) => {\n    const begin = i * chunkSize\n    return acc.concat([arr.slice(begin, begin + chunkSize)])\n  }, [])\n}\n\nconst createChunkProcessor = (\n  resolve: ReturnType<typeof makeResolver>,\n  wrap: ReturnType<typeof makeWrapper>,\n  content: string[],\n  datas: Datas,\n  columnOrder: string[],\n  separator: string,\n  chunkSize: number\n) => {\n  const chunks = toChunks(datas, chunkSize)\n  let i = 0\n  return function processChunk() {\n    if (i >= chunks.length) {\n      resolve(content)\n      return\n    }\n\n    const chunk = chunks[i]\n    i += 1\n    chunk\n      .map((v) => (Array.isArray(v) ? v : columnOrder.map((k) => v[k] ?? '')))\n      .forEach((v) => {\n        content.push(v.map(wrap).join(separator))\n      })\n\n    raf(processChunk)\n  }\n}\n\nexport interface ICsvProps {\n  columns?: Columns\n  datas: Datas | (() => Datas) | (() => Promise<Datas>) | Promise<Datas>\n  separator?: string\n  noHeader?: boolean\n  wrapColumnChar?: string\n  newLineAtEnd?: boolean\n  chunkSize?: number\n}\n\nexport default async function csv({\n  columns,\n  datas,\n  separator = ',',\n  noHeader = false,\n  wrapColumnChar = '',\n  newLineAtEnd = false,\n  chunkSize = 1000,\n}: ICsvProps) {\n  // eslint-disable-next-line no-async-promise-executor\n  return new Promise<void | string>(async (_resolve, reject) => {\n    const resolve = makeResolver(_resolve, newLineAtEnd)\n    const wrap = makeWrapper(wrapColumnChar)\n\n    try {\n      datas = typeof datas === 'function' ? await datas() : await datas\n      if (!Array.isArray(datas)) {\n        return _resolve()\n      }\n\n      const header: Record<string, string> = columns ? extractHeaderFromColumns(columns) : extractHeaderFromData(datas)\n\n      const content: string[] = []\n\n      if (!noHeader) {\n        const headerNames = Object.values(header)\n        if (headerNames.length > 0) {\n          content.push(headerNames.map(wrap).join(separator))\n        }\n      }\n\n      const columnOrder = Object.keys(header)\n\n      const processChunk = createChunkProcessor(resolve, wrap, content, datas, columnOrder, separator, chunkSize)\n\n      raf(processChunk)\n    } catch (err) {\n      return reject(err)\n    }\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}